* A hybrid component system.
There are a set of predefined components to make your life easier.
You can add new components simply by making a new defclass from component
and adding in whatever you want.

A gobj class simply has a list of components and nothing else.
Components can be added or subtracted at will and are usually defined
in the scene tree DSL but they can be programmatically made too.

** Toplevel Standard Definitions
#+BEGIN_SRC common-lisp
(defclass component ()
  ;; A reference to the gobj container holding this component.
  ((%game-object :initarg :game-object
                 :initform NIL
                 :accessor game-object)))

(defclass gobj ()
  ((%id :initarg :id
        :accessor id)
   (%components :initarg :components
                :initform NIL
                :accessor components)))
#+END_SRC

** Core Components (needs more examples as we make them)
*** Transform
*** Tags
** User-level components specific to an individual game.
#+BEGIN_SRC common-lisp
(defclass hit-points (component)
  ((%hp :initarg :hp
        :initform 0
        :accessor hp)))
#+END_SRC


* A scene tree DSL using that component system.
Here is a possible view of the scene tree DSL.

In the DSL, it expected that all game objects and components on all
game objects are referenceable in a forward manner.

The name symbol of each gobj shall have < and > bracketing it. This
is to allow them to be easly recognizable as gobj names, and to
allow the macro transformer to use them as symbol names in the
resultant expansion of the DSL into common lisp.

NOTE: Keywords cannot be used as variables in LET.

#+BEGIN_SRC common-lisp
((<player-ship>
  ;; instance components
  ((transform)
   (hit-points :hp 100))

  ;; additional subpiece of the ship in rest of list.

  (<turret>
   ((transform))

   ;; a component which allows changing between two guns in that turret
   (gun-manager
    :guns (vector (get-component 'gun <gun1>)
                  (get-component 'gun <gun2>)))

   ;; the 2 guns that the turrent can switch between
   (<gun1>
    ((transform))
    ;; a component describing the gun mechanics
    (gun
     :shots 10
     :type :beam))

   (<gun2>
    ((transform))

    (gun
     :shots 10
     :type :missle)))))
#+END_SRC

* Extensible call graph for each component
We define a MASTER graph of defmethods and transitions that are called on
all components. In this model, all components have the SAME method called
upon them, and then we move down the state graph to the next method, and
call that on all components, etc.

#+BEGIN_SRC common-lisp
(call-flow
 ;; The actual method signatures, need to see if it'll call most specific
 ;; version of the object.
 ;; These are the ONLY method the actual game engine calls on the components.
 ;; all other methods are called between game components and are defined by
 ;; the author of those components.
 ;; A library of these are defined initially and you rarely have to change it,
 ;; but if you do, you can augment it here and affect the entire expectation
 ;; of what methods are called on your components and when they are called.
 (methods
  (initialize ((c component)))
  (update ((c component)))
  (physics-update ((c component)))
  (render ((c component)))
  (destroy ((c component))))

 ;; The defined states of the control flow
 (states
  (A initialize)
  (B update)
  (C physics-update)
  (D (B C))
  (E render)
  (F destroy))

 ;; The connection graph of how the methods are called on all component
 ;; types.
 ;; NOTE: might actually put real CL here in order to inspect the
 ;; components and make decisions!
 (graph
  ;; Initialization of a component when it comes into existence.
  (A -> D)
  ;; The "game loop"
  (D -> E -> D)
  ;; when something is marked destroyed
  (E -> F)))
#+END_SRC

* An explicit component initialization description.
Apply all of the call-graph methods to all components ordered
by type of component.

#+BEGIN_SRC common-lisp
(flow-graphs

 ;; This flow graph states how to order the components when the call-flow
 ;; methods flow graph is applied to them.
 (component-method-flow
  ;; T is the root of the DAG and all paths go to NIL, the _last_ leaf
  ;; that is in the DAG. The last transition can be explicit, or
  ;; implicitly defined.

  ;; Subdags are graphs that are spliced into the dag graph whereever they are
  ;; used in the dag.
  (subdags
   (unordered ()))

  ;; Only have two components will make more for better example.
  ;; But, this says, that all transform components must have their methods
  ;; called on them BEFORE all hit-point components.
  ;;
  ;; NOTE: During generation of the code to apply this, any type discovered
  ;; that is not in the below graph automatically gets added to 'unordered'
  ;; so the ordering between those types is undefined.
  (dag
   (T -> transform -> hitpoints -> unordered -> NIL))))
#+END_SRC
