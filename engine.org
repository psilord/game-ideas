* STEP 1: A hybrid component system.
There are a set of predefined components to make your life easier.
You can add new components simply by making a new defclass from component
and adding in whatever you want.

A gobj class simply has a list of components and nothing else.
Components can be added or subtracted at will and are usually defined
in the scene tree DSL but they can be programmatically made too.

** Toplevel Standard Definitions
#+BEGIN_SRC common-lisp
(defclass component ()
  ;; A reference to the gobj container holding this component.
  ((%state :initarg :state
           :accessor state)
   (%game-object :initarg :game-object
                 :initform NIL
                 :accessor game-object)))

(defclass gobj ()
  ((%id :initarg :id
        :accessor id)
   (%state :initarg :state ;; one of: :initialize, :active, :destroy
           :accessor state
           :initform :initialize)
   ;; Keyed by instance, value is reference
   (%components :initarg :components
                :initform (make-hash-table)
                :accessor components)
   ;; Keyed by class-name of the class-of the instance,
   ;; value is a list of instances of that type.
   (%components-by-type :initarg :components-by-type
                        :accessor components-by-type
                        :initform (make-hash-table)
#+END_SRC

** Core Components (needs more examples as we make them)
*** Transform
*** Tags
** User-level components specific to an individual game.
#+BEGIN_SRC common-lisp
(defclass hit-points (component)
  ((%hp :initarg :hp
        :initform 0
        :accessor hp)))
#+END_SRC


* STEP 2: A scene tree DSL using that component system.
Here is a possible view of the scene tree DSL.

In the DSL, it expected that all game objects and components on all
game objects are referenceable in a forward manner.

The name symbol of each gobj shall have < and > bracketing it. This
is to allow them to be easly recognizable as gobj names, and to
allow the macro transformer to use them as symbol names in the
resultant expansion of the DSL into common lisp.

NOTE: Keywords cannot be used as variables in LET.

#+BEGIN_SRC common-lisp
((<player-ship>
  ;; instance components
  ((transform)
   (hit-points :hp 100))

  ;; additional subpiece of the ship in rest of list.

  (<turret>
   ((transform))

   ;; a component which allows changing between two guns in that turret
   (gun-manager
    :guns (vector (get-component 'gun <gun1>)
                  (get-component 'gun <gun2>)))

   ;; the 2 guns that the turrent can switch between
   (<gun1>
    ((transform))
    ;; a component describing the gun mechanics
    (gun
     :shots 10
     :type :beam))

   (<gun2>
    ((transform))

    (gun
     :shots 10
     :type :missle)))))
#+END_SRC

* STEP 3: Extensible call graph for each component
We define a graph called a CALL-FLOW.

It defines a function in the form of a higher order finite state
machine (HOFSM) that will subsequently be mapped over a directed
acyclic graph of type dependencies such that the instances processed
by the HOFSM will be processed in a valid topological sort of the type
dependency graph.

Before we get to the definition of the CALL-FLOW, which is
ultimately a state machine with functions that indicate transitions
to new states, we define the function that executes the CALL-FLOW.

TODO: Consider maybe add a third function to select the instances we
want to work with, this way we just pass core-state to each flow
state and the selector function figures out what instances we need,
and then the actor function runs across them in type-dag order, then
the final function returns the next state.

** Function EXECUTE-FLOW
The purpose of EXECUTE-FLOW is to map the states of the CALL-FLOW over
the component instances and other things in such a manner as to honor
a type-dependency graph.

EXECUTE-FLOW will execute a state and then determine if the state
returned by the transition function can also be executed. If it
can, it immediately executes it, and continues in this
fashion. When it comes to a state that indicates the end of a
trajectory in the HOFSM, it return the last state from when it
came, and the state which resulted in the returning of
EXECUTE-FLOW.

An arbitrary number of states may be executed by EXECUTE-FLOW and
in fact EXCEUTE-FLOW might not ever return if the HOFSM ends up in
an infinite loop.

*** EXECUTE-FLOW usage
The function (execute-flow 'ENTRY (flow 'frame-flow) core-state)
will run ONE frame's worth of flow. This is the entire main loop
of the game run over all components, game objects and other
appropriate things. Upon return of the top level HOFSM which
executes a frame, you can determine if the game should do
another frame or shutdown.

** Definition of CALL-FLOW
A CALL-FLOW contains a collection of FLOW definitions.

#+BEGIN_SRC common-lisp
(call-flow
 flow0

 flowN)
#+END_SRC

A FLOW is named contains a set of FLOW-STATE definitions.
#+BEGIN_SRC common-lisp
(flow name
      flow-state0

      flow-stateN)
#+END_SRC

A FLOW-STATE is a single state in the encompassing FLOW that
contains three things: a set of bindings that are available over
two functions, and two associated functions.

The first function selects the instances to be worked on. The
return value can be: a single instance of something, a list of
instances, a single hash table of something, a list of hash tables,
or a list of instances and hash tables.

The second function is mapped over all applicable instances and its
return value is ignored.

The third function is a state transition function that is called
just once after the first function has been mapped over the
instances, it tells the EXECUTE-FLOW driver function what is the next
state that must be executed.

The bindings are used to transfer information between all of the
first function applications to the once applied state transition
function so the state transition function can make the right
choice about which next state to choose.

Here is an example of a FLOW-STATE. This will call the
PHYSICS-UPDATE method on all instance associated with this
application of the FLOW-STATE (not specified here).

#+BEGIN_SRC common-lisp
(flow-state ENTRY/PHYSICS-UPDATE ()
            ;; Driver calls this once to get set of instances to run
            ;; the second function across.
            (lambda (core-state)
              (components-db core-state))

            ;; Driver calls this once on ALL instances selected by
            ;; the first function.
            (lambda (i &rest args)
              ;; Call User defined method.
              (apply #'physics-update i args))

            ;; Driver calls this once to get next state to go to from here.
            (lambda (core-state)
              EXIT/PHYSICS))
#+END_SRC

** Full Example of CALL-FLOW to run one frame in a main game loop
#+BEGIN_SRC common-lisp
(call-flow
 ;; Hrm. This is all single dispatch, is that good?

 ;; NOTE: If the functions inside of the state machine internally recurse
 ;; by returning the correct states, the executor will recurse forever
 ;; until something about a state transition picks a different path.

 (flow game-object-initialization-flow
       (flow-state ENTRY () ;; bindings in a let for the two functions.
                   ;; This function is run for every instance
                   (lambda (i &rest args)
                     ;; a core function, not exposed to users.
                     (apply #'spawn-game-object i args))

                   ;; After all instances have been processed, this
                   ;; function is run once by the executor in order to
                   ;; choose the next state. The let form contains
                   ;; anything we need to store while running the
                   ;; instance function which may determine the state
                   ;; we go to.
                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow component-initialization-flow
       (flow-state ENTRY ()
                   (lambda (i &rest args)
                     (apply #'reinitialize-initialize i args))

                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow component-logic-flow
       (flow-state ENTRY/PHYSICS-UPDATE ()
                   (lambda (i &rest args)
                     ;; this is the USER method they want to run at
                     ;; physics speed.
                     (apply #'physics-update i args))

                   (lambda (core-state)
                     EXIT/PHYSICS))

       (flow-state EXIT/PHYSICS ()
                   NIL)

       (flow-state ENTRY/COLLISIONS ()
                   (lambda (i &rest args)
                     ;; I don't know how this is working yet.
                     (apply #'perform-collide i args))

                   (lambda (core-state)
                     EXIT/COLLISIONS))

       (flow-state EXIT/COLLISIONS ()
                   NIL)

       ;; Once looped physics/collisions are dealt with, we can do the
       ;; rest of this flow properly.
       (flow-state ENTRY/AFTER-PHYSICS ()
                   (lambda (i &rest args)
                     (apply #'update i args))

                   (lambda (core-state)
                     RENDER))

       (flow-state RENDER ()
                   (lambda (i &rest args)
                     (apply #'render i args))
                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow game-object-maintenance-flow
       (flow-state ENTRY ()
                   (lambda (i &rest args)
                     (unless (game-object-status-p 'alive i)
                       ;; This should mark all components as
                       ;; dead and including the game-object.
                       ;; NOT a user facing API.
                       (apply #'destroy-game-object i args)))

                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FIISHED ()
                   NIL))

 (flow component-maintenance-flow
       (flow-state ENTRY ()
                   (lambda (i &rest args)
                     (unless (component-status-p 'alive i)
                       (apply #'destroy-component i args)))

                   (lambda (core-state)
                     EXIT/FLOW-FIISHED))

       (floe-state EXIT/FLOW-FINISHED () NIL))

 (flow frame-flow
       ;; First spawn any game-objects (which may or may not be empty of
       ;; components, but were created LAST frame and put into a staging area.
       (flow-state ENTRY ()
                   (lambda (core-state)
                     (execute-flow 'ENTRY
                                   (flow 'game-object-initialization-flow
                                         core-state)
                                   (game-object-init-db core-state)))

                   (lambda (core-state)
                     INIT-COMPONENTS))

       ;; Then initialize any components that need initializaing.
       (flow-state INIT-COMPONENTS ()
                   (lambda (core-state)
                     (execute-flow 'ENTRY
                                   (flow 'component-initialization-flow
                                         core-state)
                                   (component-init-db core-state)))

                   (lambda (core-state)
                     UPDATE-COMPONENTS))

       ;; Then run the component logic for all the components
       (flow-state UPDATE-COMPONENTS ()
                   (lambda (core-state)
                     ;; First, we run the physics and collision
                     ;; updates, maybe in a loop depending what is
                     ;; required.
                     (loop :with again = T
                           :while again
                           :do ;; First, run the User's physics
                               ;; functions over all ordered
                               ;; components.
                               (execute-flow
                                'ENTRY/PHYSICS-UPDATE
                                (flow 'component-logic-flow core-state)
                                (component-db core-state))

                               ;; Then, update ALL transforms to
                               ;; current local/model

                               ;; TODO: maybe wrap in box:tick?

                               ;; TODO: pass the right stuff to get
                               ;; universe root.

                               (do-nodes #'transform-node)

                               ;; Then, run any collisions that may
                               ;; have happened over ordered
                               ;; components.

                               ;; TODO, exactly figure out how to call
                               ;; collisions with the right collidees
                               ;; and such.
                               (execute-flow
                                'ENTRY/COLLISIONS
                                (flow 'component-logic-flow core-state)
                                (component-db core-state))

                               ;; Check to see if we're done doing physics.
                               (unless (physics-loop-required-p core-state)
                                 (setf again NIL)))

                     ;; Then, complete the logic for the components.
                     (execute-flow 'ENTRY/AFTER-PHYSICS
                                   (flow 'component-logic-flow core-state)
                                   (component-db core-state)))

                   (lambda (core-state)
                     GAME-OBJECT-MAINTENANCE))

       ;; if game objects are marked destroeyd, then kill all components too.
       (flow-state GAME-OBJECT-MAINTENANCE ()
                   (lambda (core-state)
                     (execute-flow 'ENTRY
                                   (flow 'game-object-maintenance-flow
                                         core-state)
                                   (game-object-db core-state)))
                   (lambda (core-state)
                     COMPONENT-MAINTENANCE))

       ;; Then, any game objects that died, or other components
       ;; previously marked as being destroyed get destroeyd.
       (flow-state COMPONENT-MAINTENANCE ()
                   (lambda (core-state)
                     (execute-flow 'ENTRY
                                   (flow 'component-maintenance-flow
                                         core-state)
                                   (component-db core-state)))
                   (lambda (core-state)
                     CONTINUE/EXIT))

       (flow-state CONTINUE/EXIT ()
                   NIL ;; no flows to run!
                   (lambda (core-state)
                     (if (exitingp core-state)
                         EXIT/GAME-OVER
                         EXIT/DO-NEXT-FRAME)))

       (flow-state EXIT/DO-NEXT-FRAME ()
                   NIL)

       (flow-state EXIT/GAME-OVER ()
                   NIL)))

#+END_SRC

* STEP 4: An explicit component initialization description.
Apply all of the call-graph methods to all components ordered
by type of component.
** Definition of TYPE-FLOW
A type-flow simply holds a pile of dag definitions.

LIMITATION: As of now, all type-flows are not namespaced, so it is
as if their union of dags exist, so, it is difficult to deal with name
collisions.


The top-level definition is
#+BEGIN_SRC common-lisp
(type-flow
 dag0

 dagN)
#+END_SRC
** Definition of DAG in TYPE-FLOW
A DAG in a type-flow is named with a symbol.

It contains zero to N forms, called a dependency form:

([T ->]? [symbol symbol* [->]?]* NIL?).

Each dependency form represents a portion of the type dependency DAG
under that dag definition. There is an implicit start node called T
that has as its children the symbol before the FIRST -> in each
dependency form. There is an implicit end node called NIL which has
an edge from all symbol after the last -> to it. You may use T and
NIL in the DAG, but they can only be in the legal places.

Here is an example of the DAG form:

#+begin_SRC common-lisp
(dag name
     (A -> B C D -> E F -> G)
     (C -> Z)
     (X -> C)
     ;; and more dependency forms if you want.
     )
#+END_SRC

*** Dependency Form Semantics
**** Symbol position semantics
Each symbol (but not ->) position in a dependency form,
(example above: A B C D X Z) can contain:
***** SYMBOL
This is a component class type name, like =transform=.

***** (SPLICE SYMBOL)
This means to splice that in scope dag name into the dag right there.
It will perform a cross product of edges into and out of the splice
as expected.

***** (SYNC SYMBOL)
This defines a fake node in the DAG (not in the same namespace
as the actual class types) that is used as a sync node in the
DAG. A sync node is just a node the flow can go through without
having to be a real type.

***** (G-SYNC symbol)
This is a *globally* defined synch node for ALL dags! Use
carefully!

***** (IMPORT symbol path)
This means to import the named dag (and all dependencies
including other imports) from the file specified and splice the dag

**** Meaning of ->
TODO


*** Nesting of DAG forms
dag forms can nest, in which case the names of the dags are
scoped properly. SYNCH nodes exist only in the dag they are used
in.  If a SYNCH node in a dag is spliced multiple times, each
synch node is different and local only to that splice.
** Example TYPE-FLOW

#+BEGIN_SRC common-lisp
(type-flow

 ;; dag unordered-types is required.
 ;; It will be filled at runtime with the names of types not specified here.
 ;; They will ahve flow-states applied in random order.
 (dag unknown-types
      (T -> NIL))

 ;; dag core-types is required
 ;; this contains all core component type names
 (dag core-types
      (T ->
         transform
         ))

 ;; dag user-types is required. In here goes the huge list of types the user
 ;; creates for components.
 (dag ordered-types
      ((import user-types "some/file/in/examples")))

 ;; dag all-types is required
 ;; This is the toplevel dag that encodes all type dependency information for
 ;; the order of application of flow-states.
 (dag all-ordered-types
      (T ->
         ;; enforce that all unknown typed components get executed first.
         ;; Why? Beats me, arbitrary decision.
         (splice unknown-types) ->
         ;; But ordered types should happen before core-types
         (splice ordered-types) ->
         ;; because this holds the results of all changes the users codes do.
         (splice core-types) ->
         NIL
         )))

#+END_SRC
* core-state instance
The core-state is an instance holding bookeeping information to
enable the execution of the methods on the components and other places.
"Game" state related to any particular game is NOT kept here.

This is somewhat soft, noted in some places.

** ALL game-objects intending to be (or are) inserted into the scene-tree
*** HASH TABLE in slot game-object-view has TWO exact keys:
'game-object-init-db
'game-object-db

The values of each are a list of actual GAME-OBJECT types.

** ALL components added to any game-object
*** HASH TABLE in slot component-view has TWO exact keys:
'component-init-db
'component-db

The values of each are a list of actual COMPONENT types.

** Scene tree
*** In slot scene-tree there is a single instance of the root object
Unknown whether to keep the initial scaffolding hash table....

** Flow Call Graph
*** HASH-TABLE in slot call-flows has N keys:
This is an example key from the above step 3, there will be N like it:

'game-object-initialization-flow

The value of the above key is a FLOW-STATE hash table.
**** FLOW-STATE HASH TABLE
The FLOW-STATE hash table is keyed by FLOW-STATE name symbols.
A flow-state value is a single instance of a specific FLOW-STATE object.

** Flow Type Call Dependency Graph
*** HASH TABLE in slot type-flows has N keys:
In step 4's DSL which isn't defined yet, there may be a similar
concept to flows. Or it might be a more traditional DAG specification.
Can't implement this slot's code until step 4 DSL and semantics
are completed.

*** HASH TABLE in slot type-views has N keys:
This is one example key, there will be many like it.
All of these keys are exactly the defclass type names of components.

'gun

The value is a list of references of all gun typed component instances
in either 'component-init-db or 'component-db above.
