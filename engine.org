* STEP 1: A hybrid component system.
There are a set of predefined components to make your life easier.
You can add new components simply by making a new defclass from component
and adding in whatever you want.

A gobj class simply has a list of components and nothing else.
Components can be added or subtracted at will and are usually defined
in the scene tree DSL but they can be programmatically made too.

** Toplevel Standard Definitions
#+BEGIN_SRC common-lisp
(defclass component ()
  ;; A reference to the gobj container holding this component.
  ((%state :initarg :state
           :accessor state)
   (%game-object :initarg :game-object
                 :initform NIL
                 :accessor game-object)))

(defclass gobj ()
  ((%id :initarg :id
        :accessor id)
   (%state :initarg :state ;; one of: :initialize, :active, :destroy
           :accessor state
           :initform :initialize)
   ;; Keyed by instance, value is reference
   (%components :initarg :components
                :initform (make-hash-table)
                :accessor components)
   ;; Keyed by class-name of the class-of the instance,
   ;; value is a list of instances of that type.
   (%components-by-type :initarg :components-by-type
                        :accessor components-by-type
                        :initform (make-hash-table)
#+END_SRC

** Core Components (needs more examples as we make them)
*** Transform
*** Tags
** User-level components specific to an individual game.
#+BEGIN_SRC common-lisp
(defclass hit-points (component)
  ((%hp :initarg :hp
        :initform 0
        :accessor hp)))
#+END_SRC


* STEP 2: A scene tree DSL using that component system.
Here is a possible view of the scene tree DSL.

In the DSL, it expected that all game objects and components on all
game objects are referenceable in a forward manner.

The name symbol of each gobj shall have < and > bracketing it. This
is to allow them to be easly recognizable as gobj names, and to
allow the macro transformer to use them as symbol names in the
resultant expansion of the DSL into common lisp.

NOTE: Keywords cannot be used as variables in LET.

#+BEGIN_SRC common-lisp
((<player-ship>
  ;; instance components
  ((transform)
   (hit-points :hp 100))

  ;; additional subpiece of the ship in rest of list.

  (<turret>
   ((transform))

   ;; a component which allows changing between two guns in that turret
   (gun-manager
    :guns (vector (get-component 'gun <gun1>)
                  (get-component 'gun <gun2>)))

   ;; the 2 guns that the turrent can switch between
   (<gun1>
    ((transform))
    ;; a component describing the gun mechanics
    (gun
     :shots 10
     :type :beam))

   (<gun2>
    ((transform))

    (gun
     :shots 10
     :type :missle)))))
#+END_SRC

* STEP 3: Extensible call graph for each component
We define a graph called a CALL-FLOW.

It defines a function in the form of a higher order finite state
machine (HOFSM) that will subsequently be mapped over a directed
acyclic graph of type dependencies such that the instances processed
by the HOFSM will be processed in a valid topological sort of the type
dependency graph.

Before we get to the definition of the CALL-FLOW, which is
ultimately a state machine with functions that indicate transitions
to new states, we define the function that executes the CALL-FLOW.

** Function EXECUTE-FLOW
The purpose of EXECUTE-FLOW is to map the states of the CALL-FLOW over
the component instances and other things in such a manner as to honor
a type-dependency graph.

EXECUTE-FLOW will execute a state and then determine if the state
returned by the transition function can also be executed. If it
can, it immediately executes it, and continues in this
fashion. When it comes to a state that indicates the end of a
trajectory in the HOFSM, it return the last state from when it
came, and the state which resulted in the returning of
EXECUTE-FLOW.

An arbitrary number of states may be executed by EXECUTE-FLOW and
in fact EXCEUTE-FLOW might not ever return if the HOFSM ends up in
an infinite loop.

*** EXECUTE-FLOW usage
The function (execute-flow 'ENTRY 'default 'frame-flow
core-state) will run the frame-flow flow from the default
call-flow. This is the entire main loop of the game run over all
components, game objects and other appropriate things. Upon
return of the top level HOFSM which executes a frame, you can
determine if the game should do another frame or shutdown.

** Definition of CALL-FLOW
A CALL-FLOW contains a collection of FLOW definitions. It has a name
that is used to identify it among multiple call flows.

#+BEGIN_SRC common-lisp
(call-flow name
           flow0

           flowN)
#+END_SRC

A FLOW is named contains a set of FLOW-STATE definitions.
#+BEGIN_SRC common-lisp
(flow name
      flow-state0

      flow-stateN)
#+END_SRC

A FLOW-STATE is a single state in the encompassing FLOW that
contains: a set of bindings that are available over three denoted
functions.

The first function selects the instances to be worked on. The
return value can be: a single instance of something, a list of
instances, a single hash table of something, a list of hash tables,
or a list of instances and hash tables.

The second function is mapped over all applicable instances and its
return value is ignored.

The third function is a state transition function that is called
just once after the first function has been mapped over the
instances, it tells the EXECUTE-FLOW driver function what is the next
state that must be executed.

The bindings are used to transfer information between all of the
first function applications to the once applied state transition
function so the state transition function can make the right
choice about which next state to choose.

Here is an example of a FLOW-STATE. This will call the
PHYSICS-UPDATE method on all instance associated with this
application of the FLOW-STATE (not specified here).

#+BEGIN_SRC common-lisp
(flow-state ENTRY/PHYSICS-UPDATE ()
            ;; Driver calls this once to get set of instances to run
            ;; the second function across.
            (lambda (core-state)
              (components-db core-state))

            ;; Driver calls this once on ALL instances selected by
            ;; the first function.
            (lambda (i &rest args)
              ;; Call User defined method.
              (apply #'physics-update i args))

            ;; Driver calls this once to get next state to go to from here.
            (lambda (core-state)
              EXIT/PHYSICS))
#+END_SRC

** COMMENT Full Example of CALL-FLOW to run one frame in a main game loop
#+BEGIN_SRC common-lisp
(call-flow
 default
 ;; Hrm. This is all single dispatch, is that good? Is there more
 ;; opportunity for CL's strengths in here?

 ;; NOTE: If the functions inside of the state machine internally recurse
 ;; by returning the correct states, the executor will recurse forever
 ;; until something about a state transition picks a different path.

 (flow game-object-initialization-flow
       (flow-state ENTRY () ;; bindings in a let for the two functions.
                   ;; Select what I want to work on.
                   (lambda (core-state)
                     (game-objects-initialize-db core-state))

                   ;; This function is run for every instance
                   (lambda (inst &rest args)
                     ;; a core function, not exposed to users.
                     (apply #'spawn-game-object inst args))

                   ;; After all instances have been processed, this
                   ;; function is run once by the executor in order to
                   ;; choose the next state. The let form contains
                   ;; anything we need to store while running the
                   ;; instance function which may determine the state
                   ;; we go to.
                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow component-initialization-flow
       (flow-state ENTRY ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (inst &rest args)
                     (apply #'reinitialize-initialize inst args))

                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow component-logic-flow
       (flow-state ENTRY/PHYSICS-UPDATE ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (inst &rest args)
                     ;; this is the USER method they want to run at
                     ;; physics speed.
                     (apply #'physics-update inst args))

                   (lambda (core-state)
                     EXIT/PHYSICS))

       (flow-state EXIT/PHYSICS ()
                   NIL)

       (flow-state ENTRY/COLLISIONS ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (inst &rest args)
                     ;; I don't know how this is working yet.
                     (apply #'perform-collide inst args))

                   (lambda (core-state)
                     EXIT/COLLISIONS))

       (flow-state EXIT/COLLISIONS ()
                   NIL)

       ;; Once looped physics/collisions are dealt with, we can do the
       ;; rest of this flow properly.
       (flow-state ENTRY/AFTER-PHYSICS ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (inst &rest args)
                     (apply #'update inst args))

                   (lambda (core-state)
                     RENDER))

       (flow-state RENDER ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (inst &rest args)
                     (apply #'render inst args))
                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow game-object-maintenance-flow
       (flow-state ENTRY ()
                   (lambda (core-state)
                     (game-objects-db core-state))

                   (lambda (inst &rest args)
                     (unless (game-object-status-p 'alive inst)
                       ;; This should mark all components as
                       ;; dead and including the game-object.
                       ;; NOT a user facing API.
                       (apply #'destroy-game-object inst args)))

                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FIISHED ()
                   NIL))

 (flow component-maintenance-flow
       (flow-state ENTRY ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (inst &rest args)
                     (unless (component-status-p 'alive inst)
                       (apply #'destroy-component inst args)))

                   (lambda (core-state)
                     EXIT/FLOW-FIISHED))

       (floe-state EXIT/FLOW-FINISHED () NIL))

 (flow frame-flow
       ;; First spawn any game-objects (which may or may not be empty
       ;; of components, but were created LAST frame and put into a
       ;; staging area.
       (flow-state ENTRY ()
                   (lambda (core-state)
                     core-state)

                   (lambda (inst)
                     (execute-flow 'ENTRY
                                   (flow 'game-object-initialization-flow inst)
                                   (game-object-init-db inst)))

                   (lambda (core-state)
                     INIT-COMPONENTS))

       ;; Then initialize any components that need initializaing.
       (flow-state INIT-COMPONENTS ()
                   (lambda (core-state)
                     core-state)

                   (lambda (inst)
                     (execute-flow 'ENTRY
                                   (flow 'component-initialization-flow inst)
                                   (component-init-db inst)))

                   (lambda (core-state)
                     UPDATE-COMPONENTS))

       ;; Then run the component logic for all the components
       (flow-state UPDATE-COMPONENTS ()
                   (lambda (core-state)
                     core-state)

                   (lambda (inst)
                     ;; First, we run the physics and collision
                     ;; updates, maybe in a loop depending what is
                     ;; required.
                     (loop :with again = T
                           :while again
                           :do ;; First, run the User's physics
                               ;; functions over all ordered
                               ;; components.
                               (execute-flow
                                'ENTRY/PHYSICS-UPDATE
                                (flow 'component-logic-flow inst)
                                ;; Fix to use type-flow
                                (component-db inst))

                               ;; Then, update ALL transforms to
                               ;; current local/model

                               ;; TODO: maybe wrap in box:tick?

                               ;; TODO: pass the right stuff to get
                               ;; universe root.

                               (do-nodes #'transform-node)

                               ;; Then, run any collisions that may
                               ;; have happened over ordered
                               ;; components.

                               ;; TODO, exactly figure out how to call
                               ;; collisions with the right collidees
                               ;; and such.
                               (execute-flow
                                'ENTRY/COLLISIONS
                                (flow 'component-logic-flow inst)
                                ;; Fix to use type-flow
                                (component-db inst))

                               ;; Check to see if we're done doing physics.
                               (unless (physics-loop-required-p inst)
                                 (setf again NIL)))

                     ;; Then, complete the logic for the components.
                     (execute-flow 'ENTRY/AFTER-PHYSICS
                                   (flow 'component-logic-flow core-state)
                                   (component-db core-state)))

                   (lambda (core-state)
                     GAME-OBJECT-MAINTENANCE))

       ;; if game objects are marked destroeyd, then kill all
       ;; components too.
       (flow-state GAME-OBJECT-MAINTENANCE ()
                   (lambda (core-state)
                     core-state)

                   (lambda (inst)
                     (execute-flow 'ENTRY
                                   (flow 'game-object-maintenance-flow inst)
                                   (game-object-db inst)))
                   (lambda (core-state)
                     COMPONENT-MAINTENANCE))

       ;; Then, any game objects that died, or other components
       ;; previously marked as being destroyed get destroeyd.
       (flow-state COMPONENT-MAINTENANCE ()
                   (lambda (core-state)
                     core-state)

                   (lambda (inst)
                     (execute-flow 'ENTRY
                                   (flow 'component-maintenance-flow inst)
                                   (component-db inst)))
                   (lambda (core-state)
                     CONTINUE/EXIT))

       (flow-state CONTINUE/EXIT ()
                   (lambda (core-state)
                     core-state)

                   NIL ;; no flows to run!

                   (lambda (inst)
                     (if (exitingp inst)
                         EXIT/GAME-OVER
                         EXIT/DO-NEXT-FRAME)))

       (flow-state EXIT/DO-NEXT-FRAME ()
                   NIL)

       (flow-state EXIT/GAME-OVER ()
                   NIL)))

#+END_SRC

* STEP 4: An explicit component initialization description.
Apply all of the call-graph methods to all components ordered
by type of component.
** Definition of TYPE-FLOW
A type-flow holds a pile of dag graph definitions. A type-flow is
named and there is a standard type-flow provided by the system
called "default".  The default type-flow is designed to load the
"project" type flow found in the user workspace. All type-flows
must have a unique name.

The top-level definition is:

#+BEGIN_SRC common-lisp
(type-flow name
           dag0

           dagN)
#+END_SRC
** Definition of DAG in TYPE-FLOW
A DAG in a type-flow is named with a symbol.

It contains zero to N forms, called a dependency form:

([symbol+ [->]?]*)

Each dependency form represents a portion of the type dependency DAG
under that dag definition.

Here is an example of the DAG form. The order of the dependency forms
themselves is not meaningful as all of them together describe the DAG.
The DAG may or may not be disjoint. A DAG by definition has no cycles.

#+BEGIN_SRC common-lisp
(dag name
     ;; first dependency form
     (A -> B C D -> E F -> G)
     ;; second dependency form
     (C -> Z)
     ;; third dependency form
     (X -> C)
     ;; and more dependency forms if you want.
     )
#+END_SRC

*** Dependency Form Semantics
**** Meaning of ->
-> means "depends on". This example:

(A -> B C D -> E)

A's state depends on B C D's state, and B C D's state depends
on E's state.

After computing the final dag, a topological sort is performed
which linearizes the state updates for all instances of the types
in question.

So E's state is updated first, then B C D is updated in any
order, then A's state.

**** Symbol position semantics
Each symbol (but not ->) position in a dependency form,
(example above: A B C D E) can contain the form:

***** SYMBOL
This is a concrete component class type name, like =transform=.

LIMITATION: At this time, midlevel inheritcance component types
cannot be specified.

***** (SPLICE SYMBOL)
This means to splice the dag name, found in the same
type-flow, into the dag right at the form location.  It will
perform a cross product of edges into and out of the splice
as expected.

***** (SPLICE TYPE-FLOW-NAME SYMBOL PATH)
Splice a dag name, found in the type-flow located in the file
at the path into the current dag at the current location.

***** (SYNC SYMBOL)
This defines a fake node in the DAG definition that is used
as a sync node in the DAG. A sync node is just a node the
flow can go through without having to be a real type. This
sync node is unique per dag and per splice of it. The name
of a sync node cannot by any type in the DAG, even gotten
through splicing.

*** Nesting of TYPE-FLOW forms
At this time type-flow forms may not nest.
*** Nesting of DAG forms
At this time dag definition forms may not nest.

** Example TYPE-FLOW

#+BEGIN_SRC common-lisp
(type-flow default
           ;; It will be filled at runtime with the names of types not
           ;; specified here.  They will have flow-states applied in
           ;; random order.
           (dag unknown-types
                ())

           ;; dag core-types is required
           ;; this contains all core component type names
           (dag core-types
                ( transform ))

           ;; dag user-flow is required. In here goes the huge list of
           ;; types the user creates for components.
           (dag ordered-types
                ((splice project user-flow "some/file/in/examples")))

           ;; dag all-types is required

           ;; This is the toplevel dag that encodes all type
           ;; dependency information for the order of application of
           ;; flow-states.
           (dag all-ordered-types
                (
                 ;; enforce that all unknown typed components get
                 ;; executed first.  Why? Beats me, arbitrary
                 ;; decision.
                 (splice unknown-types) ->
                 ;; But ordered types should happen before
                 ;; core-types
                 (splice ordered-types) ->
                 ;; because this holds the results of all changes
                 ;; the users codes do.
                 (splice core-types)
                 )))
#+END_SRC
* core-state instance
The core-state is an instance holding bookeeping information to
enable the execution of the methods on the components and other places.
"Game" state related to any particular game is NOT kept here.

It is not intended that all states of game-objects or components have
specific tables to which those objects move among.

This is somewhat soft, noted in some places.

** ALL game-objects intending to be (or are) inserted into the scene-tree
*** SLOT game-object-inititialize-db is a HASH TABLE
This hash table is keyed by a game-object reference and its value is
the game object itself. The value is the conceptual storage location for
a game-object in the initialize state.
*** SLOT game-object-active-db is a HASH TABLE
This hash table is keyed by a game-object reference and its value is
the game object itself. The value is the conceptual storage location for
a game-object and the component is in the active state.
** ALL components added to any game-object
*** SLOT component-initialize-db is a HASH TABLE
This hash table is keyed by a reference to a component instance.
The value is a reference to the component instance that is conceptually
stored in the game-object itself. Components which are in the
initializing state are referenced in this hash table.
*** SLOT component-active-db is a HASH TABLE
This hash table is keyed by a reference to a component instance.
The value is a reference to the component instance that is conceptually
stored in the game-object itself. Components which are in the
active state are referenced in this hash table.
** Scene tree
*** SLOT scene-tree is a reference to the scene-tree root game-object
** Call Flow
*** SLOT call-flow is a HASH TABLE
This hash table is keyed by the name of call-flow.  The value is
the conceptual storage location for an object describing the
call-flow. It is that object which contains information about the
flows contained in that specific call-flow.

** Type Dependency Flow
*** SLOT type-flows is a HASH TABLE
This hashtable is keyed by type-flow names. The values are the conceptual
storage location for type-flow instances that contain the description of
all named flows associated with that instance.

** Core State Internals Future Considerations
Accessing a vector is far faster than a hash table, by definition.
But accessing a hash table by object reference is pretty useful.

In experiments with SBCL 1.4.0, it is ~58 times faster to access
an array element than a hash table value with an integer key.

HOWEVER, iterating a hash table with maphash was only about 4 times
slower.

So, for now, I'll continue to use hashes, since the vast majority
of frames we're simply maphashing over them.

If even that becomes too slow, then I suspect we can store them in
an array of arrays where the first index of each stored array is
an end index. When we add something into the array, we increment
aref 0, and when we remove we REPLACE the hole closed again and
decrement index 0. In this model, the reference to the object
itself contains a slot which holds the index and reference to the
array it is contained in for easy lookup and removal.

Then, the only hashes are those keyed by class-names which we need
to implement the type dependency graph.
