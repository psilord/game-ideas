* A hybrid component system.
There are a set of predefined components to make your life easier.
You can add new components simply by making a new defclass from component
and adding in whatever you want.

A gobj class simply has a list of components and nothing else.
Components can be added or subtracted at will and are usually defined
in the scene tree DSL but they can be programmatically made too.

** Toplevel Standard Definitions
#+BEGIN_SRC common-lisp
(defclass component ()
  ;; A reference to the gobj container holding this component.
  ((%game-object :initarg :game-object
                 :initform NIL
                 :accessor game-object)))

(defclass gobj ()
  ((%id :initarg :id
        :accessor id)
   (%components :initarg :components
                :initform NIL
                :accessor components)))
#+END_SRC

** Core Components (needs more examples as we make them)
*** Transform
*** Tags
** User-level components specific to an individual game.
#+BEGIN_SRC common-lisp
(defclass hit-points (component)
  ((%hp :initarg :hp
        :initform 0
        :accessor hp)))
#+END_SRC


* A scene tree DSL using that component system.
Here is a possible view of the scene tree DSL.

In the DSL, it expected that all game objects and components on all
game objects are referenceable in a forward manner.

The name symbol of each gobj shall have < and > bracketing it. This
is to allow them to be easly recognizable as gobj names, and to
allow the macro transformer to use them as symbol names in the
resultant expansion of the DSL into common lisp.

NOTE: Keywords cannot be used as variables in LET.

#+BEGIN_SRC common-lisp
((<player-ship>
  ;; instance components
  ((transform)
   (hit-points :hp 100))

  ;; additional subpiece of the ship in rest of list.

  (<turret>
   ((transform))

   ;; a component which allows changing between two guns in that turret
   (gun-manager
    :guns (vector (get-component 'gun <gun1>)
                  (get-component 'gun <gun2>)))

   ;; the 2 guns that the turrent can switch between
   (<gun1>
    ((transform))
    ;; a component describing the gun mechanics
    (gun
     :shots 10
     :type :beam))

   (<gun2>
    ((transform))

    (gun
     :shots 10
     :type :missle)))))
#+END_SRC

* Extensible call graph for each component
We define a MASTER graph of defmethods and transitions that are called on
all components. In this model, all components have the SAME method called
upon them, and then we move down the state graph to the next method, and
call that on all components, etc.

#+BEGIN_SRC common-lisp
(call-flow
 ;; Hrm. This is all single dispatch on component, is that good?

 ;; This implies that each component (and game-object?) needs to be in
 ;; its own state.  Need to explore this and how it relates to
 ;; creating/destroying game objects as a whole. For example, when a
 ;; game-object is destroyed, does it mark all components as dead, and
 ;; the game object as dead? Then things get removed as needed?

 ;; NOTE: These state transitions *cannot* be implemented in a
 ;; recursive manner.

 (subflow component-flow
          (A (lambda (c &rest args)
               (apply #'reinitialize-initialize c args)
               B))

          (B (lambda (c &rest args)
               (apply #'update c args)
               C))

          (C (lambda (c &rest args)
               (apply #'physics-update c args)
               D))

          (D (lambda (c &rest args)
               (apply #'render c args)
               E))

          (E (lambda (c &rest args)
               ;; This component state thing needs more thought, it is
               ;; part of the core and not something a user should be
               ;; able to want to use except though API calls to
               ;; manage it (like creating a component or destroying
               ;; one).
               (if (component-status-p 'alive c)
                   ;; still alive end of this frame, set up next frame.
                   B
                   ;; dead, remove it from game at end of frame.
                   F
                   )))

          (F (lambda (c &rest args)
               (apply #'destroy-component c args)
               G))

          ;; What exactly does this mean for the component? free all references
          ;; to it so it can be GCed?
          (G NIL))


 ;; This is just like the above, but frun for game objects.
 (subflow game-object-flow
          (A (lambda (g &rest args)
               (if (game-object-status-p 'alive g)
                   ;; nothing to do, just keep trucking.
                   A
                   B)))
          (B (lambda (g &rest args)
               (apply #'destroy-game-object g args)
               C))
                                        ;l; again, figure this out.
          (C NIL))


 ;; The final flow which settles how the calls are actually run in the above
 ;; subflows.
 (flow executive-flow
       (A (lambda (game-state)
            (execute-flow (component-db game-state) component-flow)
            B))
       (B (lambda (game-state)
            (execute-flow (game-object-db game-state) game-object-flow)
            C))
       (C (lambda (game-state)
            (if (exitingp game-state)
                D
                A)))
       ;; Probably means game is over. Might need a new state to call the
       ;; cleanup functions for the entire game, if any, probably hidden in
       ;; core.
       (D NIL)))

#+END_SRC

* An explicit component initialization description.
Apply all of the call-graph methods to all components ordered
by type of component.

#+BEGIN_SRC common-lisp
(flow-graphs

 ;; This flow graph states how to order the components when the call-flow
 ;; methods flow graph is applied to them.
 (component-method-flow
  ;; T is the root of the DAG and all paths go to NIL, the _last_ leaf
  ;; that is in the DAG. The last transition can be explicit, or
  ;; implicitly defined.

  ;; Subdags are graphs that are spliced into the dag graph whereever they are
  ;; used in the dag.
  (subdags
   (unordered ()))

  ;; Only have two components will make more for better example.
  ;; But, this says, that all transform components must have their methods
  ;; called on them BEFORE all hit-point components.
  ;;
  ;; NOTE: During generation of the code to apply this, any type discovered
  ;; that is not in the below graph automatically gets added to 'unordered'
  ;; so the ordering between those types is undefined.
  (dag
   (T -> transform -> hitpoints -> unordered -> NIL))))
#+END_SRC
