* STEP 1: A hybrid component system.
There are a set of predefined components to make your life easier.
You can add new components simply by making a new defclass from component
and adding in whatever you want.

A gobj class simply has a list of components and nothing else.
Components can be added or subtracted at will and are usually defined
in the scene tree DSL but they can be programmatically made too.

** Toplevel Standard Definitions
#+BEGIN_SRC common-lisp
(defclass component ()
  ;; A reference to the gobj container holding this component.
  ((%game-object :initarg :game-object
                 :initform NIL
                 :accessor game-object)))

(defclass gobj ()
  ((%id :initarg :id
        :accessor id)
   (%components :initarg :components
                :initform NIL
                :accessor components)))
#+END_SRC

** Core Components (needs more examples as we make them)
*** Transform
*** Tags
** User-level components specific to an individual game.
#+BEGIN_SRC common-lisp
(defclass hit-points (component)
  ((%hp :initarg :hp
        :initform 0
        :accessor hp)))
#+END_SRC


* STEP 2: A scene tree DSL using that component system.
Here is a possible view of the scene tree DSL.

In the DSL, it expected that all game objects and components on all
game objects are referenceable in a forward manner.

The name symbol of each gobj shall have < and > bracketing it. This
is to allow them to be easly recognizable as gobj names, and to
allow the macro transformer to use them as symbol names in the
resultant expansion of the DSL into common lisp.

NOTE: Keywords cannot be used as variables in LET.

#+BEGIN_SRC common-lisp
((<player-ship>
  ;; instance components
  ((transform)
   (hit-points :hp 100))

  ;; additional subpiece of the ship in rest of list.

  (<turret>
   ((transform))

   ;; a component which allows changing between two guns in that turret
   (gun-manager
    :guns (vector (get-component 'gun <gun1>)
                  (get-component 'gun <gun2>)))

   ;; the 2 guns that the turrent can switch between
   (<gun1>
    ((transform))
    ;; a component describing the gun mechanics
    (gun
     :shots 10
     :type :beam))

   (<gun2>
    ((transform))

    (gun
     :shots 10
     :type :missle)))))
#+END_SRC

* STEP 3: Extensible call graph for each component
We define a MASTER graph of defmethods and transitions that are called on
all components. In this model, all components have the SAME method called
upon them, and then we move down the state graph to the next method, and
call that on all components, etc.

The function (execute-flow 'ENTRY (flow 'frame-flow) game-state) will
run ONE frame's worth of flow. This is the entire main loop of the
game. This function just gets run over and over.

EXECUTE-FLOW returns two values, the state that it was called with and
the state that was returned. This forms a state transition that we
can inspect. If the second state is NIL, then the flow has finished
executing.

#+BEGIN_SRC common-lisp
(call-flow
 ;; Hrm. This is all single dispatch, is that good?

 ;; NOTE: These state transitions *cannot* be implemented in a
 ;; recursive manner. Meaning there is an executor function that
 ;; takes care of the transitions.
 ;;
 ;; NOTE: If the functions inside of the state machine internally recurse
 ;; by returning the correct states, the executor will recurse forever
 ;; until something about a state transition picks a different path.

 ;; NOTE: Each state has TWO functions, one that is run across all applicable
 ;; instances, and the other run once by the executor to determine which next
 ;; state to go to given the information gathered from the instance executions.
 (flow game-object-initialization-flow
       (flow-state ENTRY () ;; bindings in a let for the two functions.
                   ;; This function is run for every instance
                   (lambda (i &rest args)
                     ;; a core function, not exposed to users.
                     (apply #'spawn-game-object i args))

                   ;; After all instances have been processed, this
                   ;; function is run once by the executor in order to
                   ;; choose the next state. The let form contains
                   ;; anything we need to store while running the
                   ;; instance function which may determine the state
                   ;; we go to.
                   (lambda (game-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow component-initialization-flow
       (flow-state ENTRY ()
                   (lambda (i &rest args)
                     (apply #'reinitialize-initialize i args))

                   (lambda (game-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow component-logic-flow
       (flow-state ENTRY/PHYSICS-UPDATE ()
                   (lambda (i &rest args)
                     ;; this is the USER method they want to run at
                     ;; physics speed.
                     (apply #'physics-update i args))

                   (lambda (game-state)
                     EXIT/PHYSICS))

       (flow-state EXIT/PHYSICS ()
                   NIL)

       (flow-state ENTRY/COLLISIONS ()
                   (lambda (i &rest args)
                     ;; I don't know how this is working yet.
                     (apply #'perform-collide i args))

                   (lambda (game-state)
                     EXIT/COLLISIONS))

       (flow-state EXIT/COLLISIONS ()
                   NIL)

       ;; Once looped physics/collisions are dealt with, we can do the
       ;; rest of this flow properly.
       (flow-state ENTRY/AFTER-PHYSICS ()
                   (lambda (i &rest args)
                     (apply #'update i args))

                   (lambda (game-state)
                     RENDER))

       (flow-state RENDER ()
                   (lambda (i &rest args)
                     (apply #'render i args))
                   (lambda (game-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED ()
                   NIL))

 (flow game-object-maintenance-flow
       (flow-state ENTRY ()
                   (lambda (i &rest args)
                     (unless (game-object-status-p 'alive i)
                       ;; This should mark all components as
                       ;; dead and including the game-object.
                       ;; NOT a user facing API.
                       (apply #'destroy-game-object i args)))

                   (lambda (game-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FIISHED ()
                   NIL))

 (flow component-maintenance-flow
       (flow-state ENTRY ()
                   (lambda (i &rest args)
                     (unless (component-status-p 'alive i)
                       (apply #'destroy-component i args)))

                   (lambda (game-state)
                     EXIT/FLOW-FIISHED))

       (floe-state EXIT/FLOW-FINISHED () NIL))

 (flow frame-flow
       ;; First spawn any game-objects (which may or may not be empty of
       ;; components, but were created LAST frame and put into a staging area.
       (flow-state ENTRY ()
                   (lambda (game-state)
                     (execute-flow 'ENTRY
                                   (flow 'game-object-initialization-flow
                                         game-state)
                                   (game-object-init-db game-state)))

                   (lambda (game-state)
                     INIT-COMPONENTS))

       ;; Then initialize any components that need initializaing.
       (flow-state INIT-COMPONENTS ()
                   (lambda (game-state)
                     (execute-flow 'ENTRY
                                   (flow 'component-initialization-flow
                                         game-state)
                                   (component-init-db game-state)))

                   (lambda (game-state)
                     UPDATE-COMPONENTS))

       ;; Then run the component logic for all the components
       (flow-state UPDATE-COMPONENTS ()
                   (lambda (game-state)
                     ;; First, we run the physics and collision
                     ;; updates, maybe in a loop depending what is
                     ;; required.
                     (loop :with again = T
                           :while again
                           :do ;; First, run the User's physics
                               ;; functions over all ordered
                               ;; components.
                               (execute-flow
                                'ENTRY/PHYSICS-UPDATE
                                (flow 'component-logic-flow game-state)
                                (component-db game-state))

                               ;; Then, update ALL transforms to
                               ;; current local/model

                               ;; TODO: maybe wrap in box:tick?

                               ;; TODO: pass the right stuff to get
                               ;; universe root.

                               (do-nodes #'transform-node)

                               ;; Then, run any collisions that may
                               ;; have happened over ordered
                               ;; components.

                               ;; TODO, exactly figure out how to call
                               ;; collisions with the right collidees
                               ;; and such.
                               (execute-flow
                                'ENTRY/COLLISIONS
                                (flow 'component-logic-flow game-state)
                                (component-db game-state))

                               ;; Check to see if we're done doing physics.
                               (unless (physics-loop-required-p game-state)
                                 (setf again NIL)))

                     ;; Then, complete the logic for the components.
                     (execute-flow 'ENTRY/AFTER-PHYSICS
                                   (flow 'component-logic-flow game-state)
                                   (component-db game-state)))

                   (lambda (game-state)
                     GAME-OBJECT-MAINTENANCE))

       ;; if game objects are marked destroeyd, then kill all components too.
       (flow-state GAME-OBJECT-MAINTENANCE ()
                   (lambda (game-state)
                     (execute-flow 'ENTRY
                                   (flow 'game-object-maintenance-flow
                                         game-state)
                                   (game-object-db game-state)))
                   (lambda (game-state)
                     COMPONENT-MAINTENANCE))

       ;; Then, any game objects that died, or other components
       ;; previously marked as being destroyed get destroeyd.
       (flow-state COMPONENT-MAINTENANCE ()
                   (lambda (game-state)
                     (execute-flow 'ENTRY
                                   (flow 'component-maintenance-flow
                                         game-state)
                                   (component-db game-state)))
                   (lambda (game-state)
                     CONTINUE/EXIT))

       (flow-state CONTINUE/EXIT ()
                   NIL ;; no flows to run!
                   (lambda (game-state)
                     (if (exitingp game-state)
                         EXIT/GAME-OVER
                         EXIT/DO-NEXT-FRAME)))

       (flow-state EXIT/DO-NEXT-FRAME ()
                   NIL)

       (flow-state EXIT/GAME-OVER ()
                   NIL)))

#+END_SRC


* STEP 4: An explicit component initialization description.
Apply all of the call-graph methods to all components ordered
by type of component.

#+BEGIN_SRC common-lisp
(flow-graphs

 ;; This flow graph states how to order the components when the call-flow
 ;; methods flow graph is applied to them.
 (component-method-flow
  ;; T is the root of the DAG and all paths go to NIL, the _last_ leaf
  ;; that is in the DAG. The last transition can be explicit, or
  ;; implicitly defined.

  ;; Subdags are graphs that are spliced into the dag graph whereever they are
  ;; used in the dag.
  (subdags
   (unordered ()))

  ;; Only have two components will make more for better example.
  ;; But, this says, that all transform components must have their methods
  ;; called on them BEFORE all hit-point components.
  ;;
  ;; NOTE: During generation of the code to apply this, any type discovered
  ;; that is not in the below graph automatically gets added to 'unordered'
  ;; so the ordering between those types is undefined.
  (dag
   (T -> transform -> hitpoints -> unordered -> NIL))))
#+END_SRC
* core-state instance
The core-state is an instance holding bookeeping information to
enable the execution of the methods on the components and other places.
"Game" state related to any particular game is NOT kept here.

This is somewhat soft, noted in some places.

** ALL game-objects intending to be (or are) inserted into the scene-tree
*** HASH TABLE in slot game-object-view has TWO exact keys:
'game-object-init-db
'game-object-db

The values of each are a list of actual GAME-OBJECT types.

** ALL components added to any game-object
*** HASH TABLE in slot component-view has TWO exact keys:
'component-init-db
'component-db

The values of each are a list of actual COMPONENT types.

** Scene tree
*** In slot scene-tree there is a single instance of the root object
Unknown whether to keep the initial scaffolding hash table....

** Flow Call Graph
*** HASH-TABLE in slot call-flows has N keys:
This is an example key from the above step 3, there will be N like it:

'game-object-initialization-flow

The value of the above key is a FLOW-STATE hash table.
**** FLOW-STATE HASH TABLE
The FLOW-STATE hash table is keyed by FLOW-STATE name symbols.
A flow-state value is a single instance of a specific FLOW-STATE object.

** Flow Type Call Dependency Graph
*** HASH TABLE in slot type-flows has N keys:
In step 4's DSL which isn't defined yet, there may be a similar
concept to flows. Or it might be a more traditional DAG specification.
Can't implement this slot's code until step 4 DSL and semantics
are completed.

*** HASH TABLE in slot type-views has N keys:
This is one example key, there will be many like it.
All of these keys are exactly the defclass type names of components.

'gun

The value is a list of references of all gun typed component instances
in either 'component-init-db or 'component-db above.
