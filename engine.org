* A hybrid component system.
There are a set of predefined components to make your life easier.
You can add new components simply by making a new defclass from component
and adding in whatever you want.

A gobj class simply has a list of components and nothing else.
Components can be added or subtracted at will and are usually defined
in the scene tree DSL but they can be programmatically made too.

** Toplevel Standard Definitions
#+BEGIN_SRC common-lisp
(defclass component ()
  ;; A reference to the gobj container holding this component.
  ((%game-object :initarg :game-object
                 :initform NIL
                 :accessor game-object)))

(defclass gobj ()
  ((%id :initarg :id
        :accessor id)
   (%components :initarg :components
                :initform NIL
                :accessor components)))
#+END_SRC

** Core Components (needs more examples as we make them)
*** Transform
*** Tags
** User-level components specific to an individual game.
#+BEGIN_SRC common-lisp
(defclass hit-points (component)
  ((%hp :initarg :hp
        :initform 0
        :accessor hp)))
#+END_SRC


* A scene tree DSL using that component system.
Here is a possible view of the scene tree DSL.

In the DSL, it expected that all game objects and components on all
game objects are referenceable in a forward manner.

The name symbol of each gobj shall have < and > bracketing it. This
is to allow them to be easly recognizable as gobj names, and to
allow the macro transformer to use them as symbol names in the
resultant expansion of the DSL into common lisp.

NOTE: Keywords cannot be used as variables in LET.

#+BEGIN_SRC common-lisp
((<player-ship>
  ;; instance components
  ((transform)
   (hit-points :hp 100))

  ;; additional subpiece of the ship in rest of list.

  (<turret>
   ((transform))

   ;; a component which allows changing between two guns in that turret
   (gun-manager
    :guns (vector (get-component 'gun <gun1>)
                  (get-component 'gun <gun2>)))

   ;; the 2 guns that the turrent can switch between
   (<gun1>
    ((transform))
    ;; a component describing the gun mechanics
    (gun
     :shots 10
     :type :beam))

   (<gun2>
    ((transform))

    (gun
     :shots 10
     :type :missle)))))
#+END_SRC

* Extensible call graph for each component
We define a MASTER graph of defmethods and transitions that are called on
all components. In this model, all components have the SAME method called
upon them, and then we move down the state graph to the next method, and
call that on all components, etc.

#+BEGIN_SRC common-lisp
(call-flow
 ;; Hrm. This is all single dispatch, is that good?

 ;; NOTE: These state transitions *cannot* be implemented in a
 ;; recursive manner. Meaning there is an executor function that
 ;; takes care of the transitions.
 ;;
 ;; NOTE: If the functions inside of the state machine internally recurse
 ;; by returning the correct states, the executor will recurse forever
 ;; until something about a state transition picks a different path.

 (flow game-object-initialization-flow
       (ENTRY
        (lambda (i &rest args)
          ;; Maybe not supplied to use, but internal to core.
          (apply #'spawn-game-object i args)
          EXIT/FLOW-FINISHED))

       (EXIT/FLOW-FINISHED NIL))

 (flow component-initialization-flow
       (ENTRY
        (lambda (i &rest args)
          (apply #'reinitialize-initialize i args)
          EXIT/FLOW-FINISHED))

       (EXIT/FLOW-FINISHED NIL))

 (flow component-logic-flow
       (ENTRY
        (lambda (i &rest args)
          (loop :while (must-update-physics game-state)
                ;; may need to do more than one thing in here, like
                ;; run the physics-update, then compute collisions,
                ;; then call the collide functions, etc.
                :do (apply #'physics-update i args))
          GAME-LOGIC))

       ;; Game logic
       (GAME-LOGIC
        (lambda (i &rest args)
          (apply #'update i args)
          RENDER))

       ;; render phase
       (RENDER
        (lambda (i &rest args)
          (apply #'render i args)
          CONTINUE/DISCARD))

       (CONTINUE/DISCARD
        (lambda (i &rest args)
          (if (component-status-p 'alive i)
              ;; still alive at end of this frame
              EXIT/FLOW-FINISHED
              ;; dead, remove it from game at end of frame.
              DISCARD
              )))

       ;; Driver comes back with ending state.
       (EXIT/FLOW-FINISHED NIL))

 (flow game-object-maintenance-flow
       (ENTRY
        (lambda (i &rest args)
          (if (game-object-status-p 'alive i)
              ;; nothing to do, just keep on trucking.
              EXIT/FLOW-FINISHED
              DISCARD)))

       (DISCARD
        (lambda (i &rest args)
          ;; Call user supplied function to destroy component if needed.
          (apply #'destroy-game-object i args)
          ;; Remove game object from references
          ;; TODO
          ;; Mark components as dead.
          ;; TODO
          EXIT/FLOW-FINISHED))

       (EXIT/FLOW-FIISHED NIL))

 (flow component-maintenance-flow
       (ENTRY
        (lambda (i &rest args)
          (if (component-status-p 'alive i)
              ;; still alive at end of this frame
              EXIT/FLOW-FINISHED
              ;; dead, get rid of it.
              DISCARD
              )))

       ;; end game for the component, release it.
       (DISCARD
        (lambda (i &rest args)
          (apply #'destroy-component i args)
          EXIT/FLOW-FINISHED))

       (EXIT/FLOW-FINISHED NIL))

 (flow frame-flow
       ;; First spawn any game-objects (which may or may not be empty of
       ;; components, but were created LAST frame and put into a staging area.
       (ENTRY
        (lambda (game-state)
          (execute-flow 'ENTRY
                        (flow 'game-object-initialization-flow game-state)
                        (game-object-init-db game-state))
          INIT-COMPONENTS))

       ;; Then initialize any components that need initializaing.
       (INIT-COMPONENTS
        (lambda (game-state)
          (execute-flow 'ENTRY
                        (flow 'component-initialization-flow game-state)
                        (component-init-db game-state))
          UPDATE-COMPONENTS))

       ;; Then run the component logic for all the components
       (UPDATE-COMPONENTS
        (lambda (game-state)
          (execute-flow 'ENTRY
                        (flow 'component-logic-flow game-state)
                        (component-db game-state))
          GAME-OBJECT-MAINTENANCE))

       ;; if game objects are marked destroeyd, then kill all components too.
       (GAME-OBJECT-MAINTENANCE
        (lambda (game-state)
          (execute-flow 'ENTRY
                        (flow 'game-object-maintenance-flow game-state)
                        (game-object-db game-state))
          CONTINUE/EXIT))

       (COMPONENT-MAINTENANCE
        (lambda (game-state)
          (execute-flow 'ENTRY
                        (flow 'component-maintenance-flow game-state)
                        (component-db game-state))
          CONTINUE/EXIT))

       ;; and see if we should keep going or not.
       (CONTINUE/EXIT
        (lambda (game-state)
          (if (exitingp game-state)
              EXIT/GAME-OVER
              EXIT/FLOW-FINISHED)))

       (EXIT/FLOW-FINISHED NIL)

       (EXIT/GAME-OVER NIL)))
#+END_SRC

Then, we'd exceute the flow in a simple loop that simply
calls (execute-flow 'ENTRY (flow 'frame-flow) game-state) and if
the returned state is EXIT/FLOW-FINISHED, we know we can loop again
and run another frame. If it is EXIT/GAME-OVER, then we did something
to exit the game and tear everything down and exit.

* An explicit component initialization description.
Apply all of the call-graph methods to all components ordered
by type of component.

#+BEGIN_SRC common-lisp
(flow-graphs

 ;; This flow graph states how to order the components when the call-flow
 ;; methods flow graph is applied to them.
 (component-method-flow
  ;; T is the root of the DAG and all paths go to NIL, the _last_ leaf
  ;; that is in the DAG. The last transition can be explicit, or
  ;; implicitly defined.

  ;; Subdags are graphs that are spliced into the dag graph whereever they are
  ;; used in the dag.
  (subdags
   (unordered ()))

  ;; Only have two components will make more for better example.
  ;; But, this says, that all transform components must have their methods
  ;; called on them BEFORE all hit-point components.
  ;;
  ;; NOTE: During generation of the code to apply this, any type discovered
  ;; that is not in the below graph automatically gets added to 'unordered'
  ;; so the ordering between those types is undefined.
  (dag
   (T -> transform -> hitpoints -> unordered -> NIL))))
#+END_SRC
