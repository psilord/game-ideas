* STEP 1: A hybrid component system.
There are a set of predefined components to make your life easier.
You can add new components simply by making a new defclass from component
and adding in whatever you want.

A gobj class simply has a list of components and nothing else.
Components can be added or subtracted at will and are usually defined
in the scene tree DSL but they can be programmatically made too.

** Toplevel Standard Definitions
#+BEGIN_SRC common-lisp
(defclass component ()
  ;; A reference to the gobj container holding this component.
  ((%state :initarg :state
           :accessor state)
   (%actor :initarg :actor
                 :initform NIL
                 :accessor actor)))

(defclass gobj ()
  ((%id :initarg :id
        :accessor id)
   (%state :initarg :state ;; one of: :initialize, :active, :destroy
           :accessor state
           :initform :initialize)
   ;; Keyed by instance, value is reference
   (%components :initarg :components
                :initform (make-hash-table)
                :accessor components)
   ;; Keyed by class-name of the class-of the instance,
   ;; value is a list of instances of that type.
   (%components-by-type :initarg :components-by-type
                        :accessor components-by-type
                        :initform (make-hash-table)
#+END_SRC

** Core Components Dictionary
*** Transform
*** Tags
*** Basis
Renders a 3D set of basis vectors for visualizing the orientation of an object.

** User-level components specific to an individual game.
#+BEGIN_SRC common-lisp
(defclass hit-points (component)
  ((%hp :initarg :hp
        :initform 0
        :accessor hp)))
#+END_SRC


* STEP 2: A scene tree DSL using that component system.
Here is a possible view of the scene tree DSL.

In the DSL, it expected that all game objects and components on all
game objects are referenceable in a forward manner.

The name symbol of each gobj shall have < and > bracketing it. This
is to allow them to be easly recognizable as gobj names, and to
allow the macro transformer to use them as symbol names in the
resultant expansion of the DSL into common lisp.

NOTE: Keywords cannot be used as variables in LET.

#+BEGIN_SRC common-lisp
((<player-ship>
  ;; instance components
  ((transform)
   (hit-points :hp 100))

  ;; additional subpiece of the ship in rest of list.

  (<turret>
   ((transform))

   ;; a component which allows changing between two guns in that turret
   (gun-manager
    :guns (vector (get-component 'gun <gun1>)
                  (get-component 'gun <gun2>)))

   ;; the 2 guns that the turrent can switch between
   (<gun1>
    ((transform))
    ;; a component describing the gun mechanics
    (gun
     :shots 10
     :type :beam))

   (<gun2>
    ((transform))

    (gun
     :shots 10
     :type :missle)))))
#+END_SRC

There is a problem with the above scene representation: It refers to
components that are defined both by the engine and by the user in
their own package. This presents the problem of package qualifying
symbols correctly: for example, if GUN-MANAGER was builtin to the
engine, and GUN was defined by the user, the calls to MAKE-INSTANCE
would need to be (make-instance 'gear::gun-manager ..) and
(make-instance 'user-pkg::gun) respectively. Below I present one of
many possible solutions to this problem:

#+BEGIN_SRC common-lisp
;; component macro that interns class name, slot, and accessor method symbols
;; into the gear package irrespective of the package it was defined in
;; (eg. some-user-package-xyz).
(defmacro define-component (name super-classes &body slots)
  `(defclass ,(intern (symbol-name name) :gear) (component ,@super-classes)
     ,(loop :for (slot value) :in slots
            :collect `(,(intern (format nil "%~a" slot) :gear)
                       :accessor ,(intern (symbol-name slot) :gear)
                       :initarg ,(make-keyword slot)
                       :initform ,value))))
#+END_SRC

The above macro defines a component in a concise fashion that
explicitly interns relevant symbols into the engine's package, such
that, no matter where DEFINE-COMPONENT is defined, GEAR will be the
package that 'registers' the components. Thus, the macro expansion
for the above scene can know how to instantiate or look them up by
type.

As an example, the following is a definition of a transform
component defined in *user* code for illustration purposes (in reality
it will be defined as a builtin component):

#+BEGIN_SRC common-lisp
(define-component transform ()
  (parent nil)
  (children nil)
  (translation (make-transform-state 'transform-state-vector))
  (rotation (make-transform-state 'transform-state-quaternion
                                   :incremental (vec)))
  (scale (make-transform-state 'transform-state-vector))
  (local (mid))
  (model (mid)))

;; expansion
(DEFCLASS GEAR:TRANSFORM (GEAR:COMPONENT)
  ((GEAR::%PARENT :ACCESSOR GEAR::PARENT
                  :INITARG :PARENT
                  :INITFORM NIL)
   (GEAR::%CHILDREN :ACCESSOR GEAR::CHILDREN
                    :INITARG :CHILDREN
                    :INITFORM NIL)
   (GEAR::%TRANSLATION :ACCESSOR GEAR::TRANSLATION
                       :INITARG :TRANSLATION
                       :INITFORM (GEAR:MAKE-TRANSFORM-STATE 'GEAR:TRANSFORM-STATE-VECTOR))
   (GEAR::%ROTATION :ACCESSOR GEAR::ROTATION
                    :INITARG :ROTATION
                    :INITFORM (GEAR:MAKE-TRANSFORM-STATE 'GEAR:TRANSFORM-STATE-QUATERNION :INCREMENTAL (VEC)))
   (GEAR::%SCALE :ACCESSOR GEAR::SCALE
                 :INITARG :SCALE
                 :INITFORM (GEAR:MAKE-TRANSFORM-STATE 'GEAR:TRANSFORM-STATE-VECTOR))
   (GEAR::%LOCAL :ACCESSOR GEAR::LOCAL
                 :INITARG :LOCAL
                 :INITFORM (MID))
   (GEAR::%MODEL :ACCESSOR GEAR::MODEL
                 :INITARG :MODEL
                 :INITFORM (MID))))
#+END_SRC

As can be seen in the expansion, no symbols are interned into
USER-PKG, but instead they are interned in the GEAR package.

* STEP 3: Extensible call graph for each component
We define a graph called a CALL-FLOW.

It defines a function in the form of a higher order finite state
machine (HOFSM) that will subsequently be mapped over a directed
acyclic graph of type dependencies such that the instances processed
by the HOFSM will be processed in a valid topological sort of the type
dependency graph.

Before we get to the definition of the CALL-FLOW, which is
ultimately a state machine with functions that indicate transitions
to new states, we define the function that executes the CALL-FLOW.

** Function EXECUTE-FLOW
The purpose of EXECUTE-FLOW is to map the states of the CALL-FLOW over
the component instances and other things in such a manner as to honor
a type-dependency graph.

EXECUTE-FLOW will execute a state and then determine if the state
returned by the transition function can also be executed. If it
can, it immediately executes it, and continues in this
fashion. When it comes to a state that indicates the end of a
trajectory in the HOFSM, it return the last state from when it
came, and the state which resulted in the returning of
EXECUTE-FLOW.

An arbitrary number of states may be executed by EXECUTE-FLOW and
in fact EXCEUTE-FLOW might not ever return if the HOFSM ends up in
an infinite loop.

*** EXECUTE-FLOW usage
The function (execute-flow 'ENTRY 'default 'frame-flow
core-state) will run the frame-flow flow from the default
call-flow. This is the entire main loop of the game run over all
components, game objects and other appropriate things. Upon
return of the top level HOFSM which executes a frame, you can
determine if the game should do another frame or shutdown.

** Definition of CALL-FLOW
A CALL-FLOW contains a collection of FLOW definitions. It has a name
that is used to identify it among multiple call flows.

#+BEGIN_SRC common-lisp
(call-flow name
           flow0

           flowN)
#+END_SRC

A FLOW is named contains a set of FLOW-STATE definitions.
#+BEGIN_SRC common-lisp
(flow name
      flow-state0

      flow-stateN)
#+END_SRC

A FLOW-STATE is a single state in the encompassing FLOW that
contains: a set of bindings (and a policy about those bindings)
that are available over three denoted functions. The policu indicates
if the bindings should be reset each time the state is entered, or
not. Currently only :reset is available, and required. This means
each time the state is entered, the bindings are reset to the initial
user forms in the call-flow DSL. NOTE: This will re-revaluate those
forms--in the future, this will probably be cached.

The first function selects the instances to be worked on. The
return value can be: a single instance of something, a list of
instances, a single hash table of something, a list of hash tables,
or a list of instances and hash tables.

The second function is mapped over all applicable instances and its
return value is ignored.

The third function is a state transition function that is called
just once after the first function has been mapped over the
instances, it tells the EXECUTE-FLOW driver function what is the next
state that must be executed.

The bindings are used to transfer information between all of the
first function applications to the once applied state transition
function so the state transition function can make the right
choice about which next state to choose.

Here is an example of a FLOW-STATE. This will call the
PHYSICS-UPDATE method on all instance associated with this
application of the FLOW-STATE (not specified here).

#+BEGIN_SRC common-lisp
(flow-state ENTRY/PHYSICS-UPDATE :reset ()
            ;; Driver calls this once to get set of instances to run
            ;; the second function across.
            (lambda (core-state)
              (components-db core-state))

            ;; Driver calls this once on ALL instances selected by
            ;; the first function.
            (lambda (i &rest args)
              ;; Call User defined method.
              (apply #'physics-update i args))

            ;; Driver calls this once to get next state to go to from here.
            (lambda (core-state)
              EXIT/PHYSICS))
#+END_SRC

** COMMENT Full Example of CALL-FLOW to run one frame in a main game loop
#+BEGIN_SRC common-lisp
(call-flow
 default
 ;; Hrm. This is all single dispatch, is that good? Is there more
 ;; opportunity for CL's strengths in here?

 ;; NOTE: If the functions inside of the state machine internally recurse
 ;; by returning the correct states, the executor will recurse forever
 ;; until something about a state transition picks a different path.

 (flow actor-initialization-flow
       (flow-state ENTRY :reset () ;; bindings in a let for the two functions.
                   ;; Select what I want to work on.
                   (lambda (core-state)
                     (actors-initialize-db core-state))

                   ;; This function is run for every instance
                   (lambda (core-state inst)
                     ;; a core function, not exposed to users.
                     (realize-actor inst (context core-state)))

                   ;; After all instances have been processed, this
                   ;; function is run once by the executor in order to
                   ;; choose the next state. The let form contains
                   ;; anything we need to store while running the
                   ;; instance function which may determine the state
                   ;; we go to.
                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED :reset ()
                   NIL))

 (flow component-logic-flow
       (flow-state ENTRY/PHYSICS-UPDATE :reset ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (core-state inst)
                     ;; this is the USER method they want to run at
                     ;; physics speed.
                     (physics-update inst (context core-state)))

                   (lambda (core-state)
                     EXIT/PHYSICS))

       (flow-state EXIT/PHYSICS :reset ()
                   NIL)

       (flow-state ENTRY/COLLISIONS :reset ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (core-state inst)
                     ;; I don't know how this is working yet.
                     (perform-collide inst (context core-state)))

                   (lambda (core-state)
                     EXIT/COLLISIONS))

       (flow-state EXIT/COLLISIONS :reset ()
                   NIL)

       ;; Once looped physics/collisions are dealt with, we can do the
       ;; rest of this flow properly.
       (flow-state ENTRY/AFTER-PHYSICS :reset ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (core-state inst)
                     (update inst (context core-state)))

                   (lambda (core-state)
                     RENDER))

       (flow-state RENDER :reset ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (core-state inst)
                     (render inst (context core-state)))
                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FINISHED :reset ()
                   NIL))

 (flow actor-maintenance-flow
       (flow-state ENTRY :reset ()
                   (lambda (core-state)
                     (actors-db core-state))

                   (lambda (core-state inst)
                     (unless (eq (status inst) :alive)
                       ;; This should mark all components as
                       ;; dead and including the actor.
                       ;; NOT a user facing API.
                       (destroy-actor inst (context core-state))))

                   (lambda (core-state)
                     EXIT/FLOW-FINISHED))

       (flow-state EXIT/FLOW-FIISHED :reset ()
                   NIL))

 (flow component-maintenance-flow
       (flow-state ENTRY :reset ()
                   (lambda (core-state)
                     ;; Fix to use the type-flow structures.
                     (components-db core-state))

                   (lambda (core-state inst)
                     (unless (eq (status inst) :active)
                       (destroy-component inst (context core-state))))

                   (lambda (core-state)
                     EXIT/FLOW-FIISHED))

       (flow-state EXIT/FLOW-FINISHED :reset ()
                   NIL))

 (flow frame-flow
       ;; First spawn any actors (which may or may not be empty
       ;; of components, but were created LAST frame and put into a
       ;; staging area.
       (flow-state ENTRY :reset ()
                   (lambda (core-state)
                     nil)

                   (lambda (core-state inst)
                     (execute-flow 'ENTRY
                                   (flow 'actor-initialization-flow
					 core-state)
                                   (actor-init-db core-state)))

                   (lambda (core-state)
                     INIT-COMPONENTS))

       ;; Then initialize any components that need initializaing.
       (flow-state INIT-COMPONENTS :reset ()
                   (lambda (core-state)
		     nil)

                   (lambda (core-state inst)
                     (execute-flow 'ENTRY
                                   (flow 'component-initialization-flow
					 core-state)
                                   (component-init-db core-state)))

                   (lambda (core-state)
                     UPDATE-COMPONENTS))

       ;; Then run the component logic for all the components
       (flow-state UPDATE-COMPONENTS :reset ()
                   (lambda (core-state)
                     nil)

                   (lambda (core-state inst)
                     ;; First, we run the physics and collision
                     ;; updates, maybe in a loop depending what is
                     ;; required.
                     (loop :with again = T
                           :while again
                           :do ;; First, run the User's physics
                               ;; functions over all ordered
                               ;; components.
                               (execute-flow
                                'ENTRY/PHYSICS-UPDATE
                                (flow 'component-logic-flow core-state)
                                ;; Fix to use type-flow
                                (component-db core-state))

                               ;; Then, update ALL transforms to
                               ;; current local/model

                               ;; TODO: maybe wrap in box:tick?

                               ;; TODO: pass the right stuff to get
                               ;; universe root.

                               (do-nodes #'transform-node)

                               ;; Then, run any collisions that may
                               ;; have happened over ordered
                               ;; components.

                               ;; TODO, exactly figure out how to call
                               ;; collisions with the right collidees
                               ;; and such.
                               (execute-flow
                                'ENTRY/COLLISIONS
                                (flow 'component-logic-flow core-state)
                                ;; Fix to use type-flow
                                (component-db core-state))

                               ;; Check to see if we're done doing physics.
                               (unless (physics-loop-required-p core-state)
                                 (setf again NIL)))

                     ;; Then, complete the logic for the components.
                     (execute-flow 'ENTRY/AFTER-PHYSICS
                                   (flow 'component-logic-flow core-state)
                                   (component-db core-state)))

                   (lambda (core-state)
                     ACTOR-MAINTENANCE))

       ;; if game objects are marked destroeyd, then kill all
       ;; components too.
       (flow-state ACTOR-MAINTENANCE :reset ()
                   (lambda (core-state)
                     nil)

                   (lambda (core-state inst)
                     (execute-flow 'ENTRY
                                   (flow 'actor-maintenance-flow core-state)
                                   (actor-db core-state)))
                   (lambda (core-state)
                     COMPONENT-MAINTENANCE))

       ;; Then, any game objects that died, or other components
       ;; previously marked as being destroyed get destroeyd.
       (flow-state COMPONENT-MAINTENANCE :reset ()
                   (lambda (core-state)
                     nil)

                   (lambda (core-state inst)
                     (execute-flow 'ENTRY
                                   (flow 'component-maintenance-flow
					 core-state)
                                   (component-db core-state)))
                   (lambda (core-state)
                     CONTINUE/EXIT))

       (flow-state CONTINUE/EXIT :reset ()
                   (lambda (core-state)
                     nil)

                   NIL ;; no flows to run!

                   (lambda (core-state)
                     (if (exitingp core-state)
                         EXIT/GAME-OVER
                         EXIT/DO-NEXT-FRAME)))

       (flow-state EXIT/DO-NEXT-FRAME :reset ()
                   NIL)

       (flow-state EXIT/GAME-OVER :reset ()
                   NIL)))

#+END_SRC

* STEP 4: An explicit component initialization description.
Apply all of the call-graph methods to all components ordered
by type of component.
** Definition of TYPE-FLOW
A type-flow holds a pile of dag graph definitions. A type-flow is
named and there is a standard type-flow provided by the system
called "default".  The default type-flow is designed to load the
"project" type flow found in the user workspace. All type-flows
must have a unique name.

The top-level definition is:

#+BEGIN_SRC common-lisp
(type-flow name
           dag0

           dagN)
#+END_SRC
** Definition of DAG in TYPE-FLOW
A DAG in a type-flow is named with a symbol.

It contains zero to N forms, called a dependency form:

([symbol+ [->]?]*)

Each dependency form represents a portion of the type dependency DAG
under that dag definition.

Here is an example of the DAG form. The order of the dependency forms
themselves is not meaningful as all of them together describe the DAG.
The DAG may or may not be disjoint. A DAG by definition has no cycles.

#+BEGIN_SRC common-lisp
(dag name
     ;; first dependency form
     (A -> B C D -> E F -> G)
     ;; second dependency form
     (C -> Z)
     ;; third dependency form
     (X -> C)
     ;; and more dependency forms if you want.
     )
#+END_SRC

*** Dependency Form Semantics
**** Meaning of ->
-> means "depends on". This example:

(A -> B C D -> E)

A's state depends on B C D's state, and B C D's state depends
on E's state.

After computing the final dag, a topological sort is performed
which linearizes the state updates for all instances of the types
in question.

So E's state is updated first, then B C D is updated in any
order, then A's state.

**** Symbol position semantics
Each symbol (but not ->) position in a dependency form,
(example above: A B C D E) can contain the form:

***** SYMBOL
This is a concrete component class type name, like =transform=.

LIMITATION: At this time, midlevel inheritcance component types
cannot be specified.

***** (SPLICE SYMBOL)
This means to splice the dag name, found in the same
type-flow, into the dag right at the form location.  It will
perform a cross product of edges into and out of the splice
as expected.

***** (SPLICE TYPE-FLOW-NAME SYMBOL PATH)
Splice a dag name, found in the type-flow located in the file
at the path into the current dag at the current location.

***** (SYNC SYMBOL)
This defines a fake node in the DAG definition that is used
as a sync node in the DAG. A sync node is just a node the
flow can go through without having to be a real type. This
sync node is unique per dag and per splice of it. The name
of a sync node cannot by any type in the DAG, even gotten
through splicing.

*** Nesting of TYPE-FLOW forms
At this time type-flow forms may not nest.
*** Nesting of DAG forms
At this time dag definition forms may not nest.

** Example TYPE-FLOW

#+BEGIN_SRC common-lisp
(type-flow default
           ;; It will be filled at runtime with the names of types not
           ;; specified here.  They will have flow-states applied in
           ;; random order.
           (dag unknown-types
                ())

           ;; dag core-types is required
           ;; this contains all core component type names
           (dag core-types
                ( transform ))

           ;; dag user-flow is required. In here goes the huge list of
           ;; types the user creates for components.
           (dag ordered-types
                ((splice project user-flow "some/file/in/examples")))

           ;; dag all-types is required

           ;; This is the toplevel dag that encodes all type
           ;; dependency information for the order of application of
           ;; flow-states.
           (dag all-ordered-types
                (
                 ;; enforce that all unknown typed components get
                 ;; executed first.  Why? Beats me, arbitrary
                 ;; decision.
                 (splice unknown-types) ->
                 ;; But ordered types should happen before
                 ;; core-types
                 (splice ordered-types) ->
                 ;; because this holds the results of all changes
                 ;; the users codes do.
                 (splice core-types)
                 )))
#+END_SRC
* core-state instance
The core-state is an instance holding bookeeping information to
enable the execution of the methods on the components and other places.
"Game" state related to any particular game is NOT kept here.

It is not intended that all states of actors or components have
specific tables to which those objects move among.

This is somewhat soft, noted in some places.
** Context
*** SLOT context is an INSTANCE of class context
The core-state holds a CONTEXT object that is passed to all
protocol functions for components via exceute-flow. It holds
at LEAST time related attributes, like time since start of game,
current time, delta-time since last frame, etc.
** ALL actors intending to be inserted into the scene-tree
*** SLOT actor-inititialize-db is a HASH TABLE
This hash table is keyed by a actor reference and its value is
the game object itself. The value is the conceptual storage location for
a actor in the initialize state.
*** SLOT actor-initialize-thunks-db is a HASH TABLE
This hash table is keyed by a reference to the actor
instance. The value is the list of thunks needed to initialize
all the components in the actor. The value is removed after the
thunks are executed. The thunks are only executed once.
*** SLOT actor-active-db is a HASH TABLE
This hash table is keyed by a actor reference and its value is
the game object itself. The value is the conceptual storage location for
a actor and the component is in the active state.
** ALL components added to any actor
*** SLOT component-initialize-view is a HASH TABLE
This hash table is keyed by a reference to a component instance.
The value is a reference to the component instance that is conceptually
stored in the actor itself. Components which are in the
initializing state are referenced in this hash table.
*** SLOT component-active-view is a HASH TABLE
This hash table is keyed by a reference to a component instance.
The value is a reference to the component instance that is conceptually
stored in the actor itself. Components which are in the
active state are referenced in this hash table.
** Scene tree
*** SLOT scene-table is a HASH-TABLE
This slot holds a hash table keyed by symbols, often keywords, whose
values are thunks that represent an injection of a set of actors from
a scene-definition dsl into the core-state. When preparing scenes,
all prepared scenes end up in this same hash table.
*** SLOT scene-tree is a reference to the scene-tree root actor
The object being referenced is conceptually stored in the slot
actor-active-db.
** Call Flow
*** SLOT call-flow-table is a HASH TABLE
This hash table is keyed by the name of call-flow.  The value is
the conceptual storage location for an object describing the
call-flow. It is that object which contains information about the
flows contained in that specific call-flow.
**** TODO Define call-flow object internals (and flow-state internals)
** Type Dependency Flow
*** SLOT type-flows is a HASH TABLE
This hashtable is keyed by type-flow names. The values are the conceptual
storage location for type-flow instances that contain the description of
all named flows associated with that instance.
**** TODO Define type-flow object internals (and flow object internals)
*** SLOT unknown-type is a SYMBOL
This gensymed symbol represents the "unknown" type where all component
instance types that are not directly specified in the type-flow get
stored.
*** SLOT component-type-view is a HASH TABLE
The key for this hash table is a concrete component type (or the
unknown sentinel) and the value is a second hash table. This
second hash table's key is a reference to a component.  The
second hash table's value is a reference to the same component
which is conceptually stored in the actor.
*** SLOT sorted-type-dependencies is a LIST
This list contains, as a topological sort of the type-dependency
graph, from left to right, symbol names of concrete types (or
the unknown sentinel) in a topological sort of depndencies. The first
entry is the earliest type that must be processed before moving
on to types that depend on it.
** Core State API
*** Function MAKE-CORE-STATE
Return a corestate instance. Take initargs, but usually none need to
be defined.

*** Function ADD-SCENE-TREE-ROOT
#+BEGIN_SRC common-lisp
(ADD-SCENE-TREE-ROOT core-state actor)
#+END_SRC

This function sets the scene-tree slot in core-state to the
supplied actor.
*** Function ADD-INITIALIZING-ACTOR
#+BEGIN_SRC common-lisp
(ADD-INITIALIZING-ACTOR core-state actor initializer-thunk-list)
#+END_SRC

This function takes a core-state, the actor (filled with
components), and the initializer-thunk-list which contains a
list of thunks taking no arguments. Each thunk will be run once
at the appropriate time, to ensure the components in the object
are initialized before they enter the scene tree.
** Core State Internals Future Considerations
Accessing a vector is far faster than a hash table, by definition.
But accessing a hash table by object reference is pretty useful.

In experiments with SBCL 1.4.0, it is ~58 times faster to access
an array element than a hash table value with an integer key.

HOWEVER, iterating a hash table with maphash was only about 4 times
slower.

So, for now, I'll continue to use hashes, since the vast majority
of frames we're simply maphashing over them.

If even that becomes too slow, then I suspect we can store them in
an array of arrays where the first index of each stored array is
an end index. When we add something into the array, we increment
aref 0, and when we remove we REPLACE the hole closed again and
decrement index 0. In this model, the reference to the object
itself contains a slot which holds the index and reference to the
array it is contained in for easy lookup and removal.

Then, the only hashes are those keyed by class-names which we need
to implement the type dependency graph.
